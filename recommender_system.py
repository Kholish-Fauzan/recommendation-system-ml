# -*- coding: utf-8 -*-
"""Recommender_System (101).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16BgbiyFoXAFnk5L3FspGCE033ejhM5Vn

# Laporan Proyek Machine Learning - Ahmad Kholish Fauzan Shobiry

## Project Overview
### Latar Belakang
Proyek ini bertujuan untuk mengembangkan sistem rekomendasi lagu berbasis konten (Content-Based Filtering) menggunakan fitur deskriptif dari lagu seperti nama lagu, artis, album, dan genre. Sistem ini akan membantu pengguna menemukan lagu yang mirip dengan preferensi mereka berdasarkan kesamaan fitur musik.

### Tujuan Proyek
Proyek ini bertujuan untuk membangun sistem rekomendasi musik berbasis content-based filtering dengan tujuan:
1. Membantu pengguna menemukan lagu-lagu baru yang mirip dengan lagu favorit mereka.
2. Memberikan pengalaman mendengarkan musik yang lebih personal dan relevan.
3. Memanfaatkan fitur audio dari lagu seperti danceability, valence, dan tempo untuk menghasilkan rekomendasi yang sesuai dengan preferensi pengguna.

### Ruang Lingkup
Proyek difokuskan pada sistem rekomendasi lagu berbasis content-based filtering dengan pendekatan sebagai berikut:
1. Dataset yang digunakan adalah Spotify Tracks Dataset dari Kaggle.
2. Sistem akan menggunakan fitur-fitur numerik seperti danceability, energy, acousticness, valence, dan tempo untuk menghitung kemiripan antar lagu.
3. Rekomendasi dihasilkan dengan menghitung kemiripan fitur menggunakan cosine similarity pada setiap model.
4. Menghitung nilai Precision@K pada kualitas sistem rekomendasi.

### Referensi
- [Dataset: Spotify Tracks Dataset – Kaggle](https://www.kaggle.com/datasets/maharshipandya/-spotify-tracks-dataset)

## Business Understanding
### Problem Statements
1. Bagaimana cara merekomendasikan lagu yang serupa dengan lagu favorit pengguna berdasarkan fitur-fitur kontennya?
2. Bagaimana membantu pengguna menemukan lagu baru yang sesuai dengan selera musik mereka tanpa harus mencari secara manual?

### Goals
1. Mengembangkan sistem rekomendasi lagu berbasis konten yang dapat menyarankan lagu-lagu serupa dari fitur yang tersedia seperti nama lagu, artis, genre, dan album.
2. Meningkatkan pengalaman pengguna dalam menemukan musik baru dengan pendekatan personal dan otomatis.

### Solution Statements
1. Pendekatan: Content-Based Filtering dengan menggunakan fitur-fitur deskriptif (track_name, artists, album_name, track_genre) yang diubah menjadi representasi vektor menggunakan TF-IDF, lalu dihitung kesamaannya menggunakan ANN.
2. Fitur tambahan: Potensi penggunaan fitur audio seperti danceability, energy, valence, atau tempo untuk meningkatkan kualitas rekomendasi (di tahap pengembangan lanjutan).
3. Mengukur hasil kemiripan fitur menggunakan Cosine Similarity.
4. Melakukan evaluasi menggunakan Precision@K untuk menilai kualitas rekomendasi berdasarkan Ground Truth.

## Data Understanding
Dataset yang digunakan adalah Spotify Tracks Dataset yang berisi 114.000 lagu dari 125 genre berbeda. Setiap lagu memiliki informasi deskriptif serta fitur audio yang diperoleh dari Spotify API.

### Format File
Dataset disimpan dalam format .csv dan telah dimuat ke Google Colab melalui path: /kaggle/input/-spotify-tracks-dataset/dataset.csv.

### Statistik Dataset
1. Jumlah lagu: 114.000
2. Jumlah genre: 114
3. Jumlah artis unik: ribuan
4. Distribusi genre cukup seimbang: sebagian besar genre memiliki 1.000 lagu

### Variabel dalam Dataset
Berikut merupakan variabel-variabel dalam dataset, antara lain:
1. Unnamed:0: Kolom indeks baris.
2. track_id: ID unik lagu dari Spotify.
3. artists: Nama penyanyi atau grup musik; jika lebih dari satu, dipisahkan dengan tanda titik koma (;).
4. album_name: Nama album tempat lagu tersebut dimuat.
5. track_name: Judul lagunya
6. popularity: Tingkat popularitas lagu (skala 0–100); makin tinggi berarti makin sering didengarkan saat ini.
7. duration_ms: Durasi lagu dalam milidetik
8. explicit: Apakah lagu mengandung lirik eksplisit (true = ya, false = tidak/kurang jelas).
9. danceability: Seberapa cocok lagu untuk menari (0.0 = tidak cocok, 1.0 = sangat cocok).
10. energy: Ukuran intensitas dan aktivitas lagu (0.0 = tenang, 1.0 = sangat energik).
11. key: Nada dasar lagu (0 = C, 1 = C♯/D♭, dst; -1 jika tidak terdeteksi).
12. loudness: Tingkat keras suara lagu dalam desibel (dB)
13. mode: Skala lagu; 1 = mayor (ceria), 0 = minor (sedih).
14. speechiness: Seberapa banyak unsur bicara dalam lagu (0.0 = musik murni, 1.0 = penuh bicara)
15. acousticness: Keyakinan bahwa lagu bersifat akustik (0.0 = tidak akustik, 1.0 = sangat akustik).
16. instrumentalness: Perkiraan bahwa lagu tidak memiliki vokal (0.0 = banyak vokal, 1.0 = full instrumental).
17. liveness: Kemungkinan lagu direkam secara langsung di hadapan penonton (nilai > 0.8 = kemungkinan besar live).
18. valence: Tingkat nuansa emosional positif dalam lagu (0.0 = sedih, 1.0 = bahagia).
19. tempo: Kecepatan lagu dalam beat per menit (BPM).
20. time_signature: Tanda birama lagu (jumlah ketukan per bar; biasanya antara 3 sampai 7).
21. track_genre: Genre atau jenis musik lagu tersebut.

## Data Preparation
Pada tahap ini, dilakukan sejumlah proses pembersihan dan transformasi data untuk memastikan bahwa dataset siap digunakan dalam pengembangan sistem rekomendasi musik. Beberapa langkah utama yang dilakukan meliputi:

1. Mengatasi Missing Values
<br>Beberapa kolom dalam dataset dapat mengandung nilai kosong (NaN) yang perlu ditangani agar tidak mengganggu proses pembentukan fitur dan pemodelan sistem rekomendasi. Strategi yang digunakan antara lain:
<br> - Menghapus baris dengan nilai kosong pada kolom penting seperti track_name, artists, dan fitur audio (danceability, energy, dll).
<br> - Untuk kolom seperti album_name, dapat diisi dengan string kosong ("") jika dianggap tidak terlalu mempengaruhi rekomendasi.

2. Memastikan Tipe Data
<br>Beberapa kolom perlu dikonversi ke tipe data yang sesuai agar proses analisis dan komputasi berjalan dengan optimal:
<br> - Kolom duration_ms dikonversi menjadi detik agar lebih mudah dibaca.
<br> - Kolom explicit dikonversi ke tipe boolean (True/False).
<br> - Kolom numerik seperti popularity, danceability, energy, valence, dan tempo dikonversi ke tipe float untuk kebutuhan pemodelan.

3. Membuat Fitur Gabungan
<br>Untuk mendukung pendekatan content-based filtering, dibuat representasi fitur numerik yang dapat digunakan untuk menghitung kemiripan antar lagu:
<br> - Digunakan fitur-fitur audio utama yang bersifat numerik seperti:
  1. danceability
  2. energy
  3. valence
  4. acousticness
  5. instrumentalness
  6. tempo
  7. speechiness
  8. liveness
  
<br>Kolom track_genre juga dapat digunakan sebagai informasi tambahan untuk segmentasi atau analisis deskriptif.

Fitur-fitur ini akan digunakan dalam proses ekstraksi vektor fitur dan perhitungan similarity antar lagu untuk menghasilkan rekomendasi.
"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("maharshipandya/-spotify-tracks-dataset")

print("Path to dataset files:", path)

# Import library dasar
import pandas as pd
import numpy as np

# Load dataset
df = pd.read_csv('/kaggle/input/-spotify-tracks-dataset/dataset.csv')

# Tampilkan 5 data teratas
df.head()

# Lihat info dataset
df.info()

# Cek missing values
df.isnull().sum()

# Cek jumlah genre unik
print(f"Jumlah genre unik: {df['track_genre'].nunique()}")
print(df['track_genre'].value_counts().head(10))

"""Dataset memiliki 114.000 baris dan 21 kolom, dengan kolom penting seperti track_name, artists, album_name, dan track_genre hampir seluruhnya lengkap (hanya 1 missing value per kolom teks). Terdapat 114 genre unik dengan jumlah lagu per genre relatif seimbang (seribu lagu per genre).

Dataset memiliki satu kolom yang tidak penting untuk diproses yakni kolom dengan nama `Unnamed: 0 ` karena hanya menunujukkan indeks nomor baris dalam dataset sehingga dapat di drop saja.


---

Diketahui bahwa kolom teks seperti track_name, artists, dan album_name memiliki 1 missing value. Karena ini merupakan sistem rekomendasi dimana berbasis Content-Based Filtering, maka 3 kolom tersebut sangat penting untuk diketahui isinya, karena terdapat missing value pada 3 kolom tersebut dan jumlahnya sangat sedikit, maka bisa dihapus saja karena tidak akan memperngaruhi pengolahan data keseluruhan.
"""

# Menghapus kolom tidak penting
df = df.drop(columns=['Unnamed: 0'])

# Mengisi missing value pada kolom teks deskriptif
text_cols = ['track_name', 'artists', 'album_name']
df[text_cols] = df[text_cols].fillna("")

# Cek apakah masih ada missing value
print(df[text_cols].isnull().sum())

# Untuk memastikan tidak ada duplikasi dalam judul lagu, maka track_name dengan nilai yang sama akan di drop berdasarkan tingkat popularitynya
df = df.sort_values(by='popularity', ascending=False)
df = df.drop_duplicates(subset='track_name', keep='first')

# Memastikan bahwa hasil rekomendasi menampilkan Lagu yang memiliki judul saja
df = df[~df['track_name'].isnull()]
df = df[df['track_name'].str.strip() != '']

# Memastikan bahwa hasil rekomendasi menampilkan Lagu dengan nama Band atau Penyanyi yang jelas saja
df = df[~df['artists'].isnull()]
df = df[df['artists'].str.strip() != '']
df = df.reset_index(drop=True)

# Memastikan popularitas dan durasi bertipe numerik
df['popularity'] = pd.to_numeric(df['popularity'], errors='coerce')
df['duration_ms'] = pd.to_numeric(df['duration_ms'], errors='coerce')

"""Selanjutnya membuat kolom combined_features yang menggabungkan informasi dari: track_name, artists, album_name, dan track_genre. Gabungan ini akan menjadi dasar sistem rekomendasi berbasis konten."""

# Fungsi untuk menggabungkan fitur-fitur deskriptif
def combine_features(row):
    return (
        row['track_name'] + ' ' +
        (row['artists'] + ' ') * 2 +     # Artist dibobotkan 2x
        (row['album_name'] + ' ') +      # Album 1x
        (row['track_genre'] + ' ') * 3   # Genre dibobotkan 3x
    ).lower()

# Terapkan ke dataframe
df['combined_features'] = df.apply(combine_features, axis=1)

# Cek hasil awal
df[['track_name', 'combined_features']].head()

import warnings
warnings.filterwarnings('ignore')

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi dan fit-transform data dengan stop words bahasa Inggris
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['combined_features'])

# Ukuran TF-IDF matrix
print("Ukuran TF-IDF matrix:", tfidf_matrix.shape)

from sklearn.neighbors import NearestNeighbors

# Inisialisasi dan training model ANN
model_ann_text = NearestNeighbors(metric='cosine', algorithm='brute')
model_ann_text.fit(tfidf_matrix)

"""## Modelling

Sesuai dengan Solution Statements yang telah ditentukan, sistem rekomendasi musik ini akan dikembangkan melalui beberapa pendekatan, antara lain:


- **Pendekatan 1: Content-Based Filtering Berbasis Metadata Teks**
<br> Sistem merekomendasikan lagu berdasarkan kemiripan konten deskriptif dari lagu yang dipilih oleh pengguna. Informasi yang digunakan meliputi:
<br> - track_name (judul lagu)
<br> - artists (nama penyanyi atau band)
<br> - album_name (nama album)
<br> - track_genre (genre musik)
<br>Seluruh informasi tersebut digabung dalam satu kolom bernama combined_features, kemudian direpresentasikan sebagai vektor teks menggunakan TF-IDF (Term Frequency–Inverse Document Frequency). Kemiripan antar lagu dihitung menggunakan algoritma Approximate Nearest Neighbors (ANN) melalui NearestNeighbors dari Scikit-Learn.

- **Pendekatan 2: Content-Based Filtering Berbasis Fitur Audio**
<br>Selain metadata, sistem juga memanfaatkan fitur numerik audio dari tiap lagu, antara lain variabel `danceability, energy, valence, tempo, acousticness, instrumentalness, speechiness, dan liveness`.
<br>Fitur-fitur ini menggambarkan karakteristik teknis dari lagu dan diolah sebagai berikut:
<br> - Normalisasi fitur numerik menggunakan MinMaxScaler
<br> - Perhitungan kemiripan antar lagu menggunakan ANN
<br> - Penyajian lagu-lagu terdekat berdasarkan kemiripan vektor audio
<br>Kelebihan:
<br>Pendekatan ini mampu menyarankan lagu-lagu dengan mood, energi, atau gaya musik yang mirip, bahkan jika berasal dari genre atau artis yang berbeda.

- **Pendekatan 3: Rekomendasi Berdasarkan Genre**
<br>Sistem juga menyediakan rekomendasi berbasis genre, di mana lagu-lagu dengan genre yang sama dengan lagu input akan disaring, lalu disusun berdasarkan popularitas (popularity) tertinggi.

-  **Pendekatan 4: Hybrid Filtering: Teks + Audio**
<br>Sistem ini menggabungkan skor dari dua model ANN:
<br> - TF-IDF (representasi metadata teks)
<br> - ANN untuk fitur numerik audio
<br>Gabungan skor menggunakan parameter alpha untuk mengatur bobot kontribusi masing-masing model.
<br>Contoh: alpha = 0.5 memberi kontribusi seimbang antara teks dan audio.
<br>Menghasilkan rekomendasi yang lebih seimbang dari sisi semantik dan musikalitas.

-  **Pendekatan 5: Hybrid Filtering: Audio + Genre**
<br>Pendekatan ini menggabungkan:
<br> - Kemiripan fitur audio (melalui ANN)
<br> - Filter berdasarkan genre yang sama
<br>Setelah menemukan lagu-lagu mirip secara audio, sistem menyaring hanya lagu-lagu dengan genre yang sesuai.
<br>Kelebihan: Menghasilkan rekomendasi lagu yang memiliki mood serupa sekaligus mempertahankan genre musik yang disukai.

### Tujuan Modelling
Melalui lima pendekatan ini, sistem rekomendasi ini bertujuan untuk:
1. Menyediakan rekomendasi lagu yang personal dan kontekstual
2. Memberikan fleksibilitas pendekatan sesuai preferensi pengguna
3. Menggabungkan kekuatan teks deskriptif dan fitur akustik dalam satu sistem
4. Membantu pengguna menemukan lagu-lagu baru yang relevan berdasarkan kesamaan gaya, suasana, dan genre

**Rekomendasi Lagu berbasis Kemiripan Text**
"""

from sklearn.metrics.pairwise import cosine_similarity

def recommend_songs_text_based(song_title, df=df, model=model_ann_text, tfidf_matrix=tfidf_matrix, top_n=10):
    # Cari index lagu berdasarkan judul
    idx = df[df['track_name'].str.lower() == song_title.lower()].index
    if len(idx) == 0:
        return f"Lagu '{song_title}' tidak ditemukan dalam database."

    idx = idx[0]
    fitur_lagu = tfidf_matrix[idx]

    # Temukan tetangga terdekat menggunakan ANN
    distances, indices = model.kneighbors(fitur_lagu, n_neighbors=top_n + 1)

    # Ambil indeks lagu selain lagu itu sendiri (idx 0)
    recommended_indices = indices.flatten()[1:]

    # Hitung cosine similarity untuk tiap rekomendasi
    similarities = cosine_similarity(fitur_lagu, tfidf_matrix[recommended_indices]).flatten()

    # Cetak rata-rata similarity
    print(f"[Text-Based] Rata-rata cosine similarity: {np.mean(similarities):.4f}")

    # Gabungkan hasil rekomendasi dengan skor similarity-nya
    results = df.iloc[recommended_indices][['track_name', 'artists', 'track_genre']].copy()
    results['cosine_similarity'] = similarities

    return results.sort_values(by='cosine_similarity', ascending=False).reset_index(drop=True)

"""Fungsi di atas akan memberikan rekomendasi lagu berdasarkan kemiripan teks (judul, artis, genre, dll.) menggunakan model Approximate Nearest Neighbors (ANN) dan representasi TF-IDF.
Langkah-langkah yang akan dilakukan dalam kode tersebut:
1. Mencari indeks lagu berdasarkan judul input.
2. Mengambil lagu-lagu terdekat dari model ANN berdasarkan vektor TF-IDF.
3. Mengembalikan daftar lagu yang mirip (tanpa menyertakan lagu itu sendiri).
"""

recommend_songs_text_based("Levitating")

"""**Rekomendasi Lagu Berbasis Kemiripan Audio**"""

# Menggabungkan numerical features audio utama untuk sistem rekomendasi berbasis fitur audio dalam lagu.
audio_features = [
    'danceability', 'energy', 'valence', 'acousticness',
    'instrumentalness', 'tempo', 'speechiness', 'liveness'
]

from sklearn.preprocessing import StandardScaler

# Ekstrak fitur numerik
X_audio = df[audio_features]

# Normalisasi fitur
scaler = StandardScaler()
X_audio_scaled = scaler.fit_transform(X_audio)

from sklearn.neighbors import NearestNeighbors

# Gunakan cosine metric untuk kemiripan
model_audio_ann = NearestNeighbors(metric='cosine', algorithm='brute')
model_audio_ann.fit(X_audio_scaled)

def recommend_songs_audio_based(song_title, df=df, model=model_audio_ann, X_audio_scaled=X_audio_scaled, top_n=10):
    # Cari index lagu berdasarkan judul
    idx = df[df['track_name'].str.lower() == song_title.lower()].index
    if len(idx) == 0:
        return f"Lagu '{song_title}' tidak ditemukan dalam database."

    idx = idx[0]
    fitur_lagu = X_audio_scaled[idx].reshape(1, -1)

    # Temukan tetangga terdekat menggunakan ANN
    distances, indices = model.kneighbors(fitur_lagu, n_neighbors=top_n + 1)

    # Ambil indeks tanpa lagu itu sendiri (idx 0)
    recommended_indices = indices.flatten()[1:]

    # Hitung cosine similarity
    similarities = cosine_similarity(fitur_lagu, X_audio_scaled[recommended_indices]).flatten()

    # Cetak rata-rata similarity
    print(f"[Audio-Based] Rata-rata cosine similarity: {np.mean(similarities):.4f}")

    # Gabungkan hasil dengan similarity score
    results = df.iloc[recommended_indices][['track_name', 'artists', 'track_genre']].copy()
    results['cosine_similarity'] = similarities

    return results.sort_values(by='cosine_similarity', ascending=False).reset_index(drop=True)

"""Selanjutnya, fungsi diatas memberikan rekomendasi lagu berdasarkan kemiripan fitur audio (seperti danceability, energy, valence, dll.) menggunakan model Approximate Nearest Neighbors (ANN).
Langkah-langkah:
1. Mencari indeks lagu berdasarkan judul input.
2. Mengambil lagu-lagu terdekat dari model ANN berdasarkan fitur audio yang sudah dinormalisasi.
3. Mengembalikan daftar lagu yang mirip secara karakteristik audio, tanpa menyertakan lagu itu sendiri.
"""

recommend_songs_audio_based("Levitating")

"""**Rekomendasi Lagu berbasis Kemiripan Genre**"""

def recommend_and_evaluate_by_genre(song_title, df=df, top_n=10):
    # Cari lagu yang sesuai
    song = df[df['track_name'].str.lower() == song_title.lower()]
    if song.empty:
        return f"Lagu '{song_title}' tidak ditemukan dalam database."

    genre = song.iloc[0]['track_genre']

    # Cari lagu lain dengan genre yang sama
    similar_genre_songs = df[(df['track_genre'] == genre) & (df['track_name'].str.lower() != song_title.lower())]

    if similar_genre_songs.empty:
        return 'Tidak ada lagu lain dengan genre yang sama.'

    # Ambil top N lagu secara acak jika jumlahnya lebih dari top_n
    if len(similar_genre_songs) > top_n:
        similar_genre_songs = similar_genre_songs.sample(top_n, random_state=42)

    # Asumsikan semua similarity = 1.0
    similarities = [1.0] * len(similar_genre_songs)
    print(f"[Genre-Based] Rata-rata cosine similarity (asumsi): {np.mean(similarities):.4f}")

    # Buat DataFrame untuk menampilkan hasil
    results_df = similar_genre_songs[['track_name', 'artists', 'track_genre']].copy()
    results_df['cosine_similarity'] = similarities

    return results_df

"""Kode di atas akan menjalankan langkah-langkah berikut:
1. Menemukan genre dari lagu yang dicari.
2. Memfilter lagu-lagu lain dengan genre yang sama, kecuali lagu itu sendiri.
3. Mengembalikan sejumlah lagu secara acak dari genre tersebut (maksimal top_n lagu).

Sehingga menghasilkan rekomendasi lagu berdasarkan genre yang sama
"""

recommend_and_evaluate_by_genre("Levitating")

"""**Rekomendasi Lagu berbasis Kemiripan Text dan Audio Features (Hybrid)**"""

def recommend_and_evaluate_hybrid_text_audio(song_title, df=df, tfidf_matrix=tfidf_matrix, audio_features=X_audio_scaled,
                                             model_text=model_ann_text, model_audio=model_audio_ann, top_n=10, alpha=0.5):
    # Cari index lagu
    idx = df[df['track_name'].str.lower() == song_title.lower()].index
    if len(idx) == 0:
        return f"Lagu '{song_title}' tidak ditemukan dalam database."
    idx = idx[0]

    # ===== TEXT-BASED SIMILARITY =====
    _, text_indices = model_text.kneighbors(tfidf_matrix[idx], n_neighbors=top_n+20)
    text_indices = text_indices.flatten()
    text_scores = np.linspace(1, 0, len(text_indices))  # Semakin jauh, skornya makin kecil

    # ===== AUDIO-BASED SIMILARITY =====
    _, audio_indices = model_audio.kneighbors([audio_features[idx]], n_neighbors=top_n+20)
    audio_indices = audio_indices.flatten()
    audio_scores = np.linspace(1, 0, len(audio_indices))

    # Gabungkan skor
    combined_scores = {}
    for i, score in zip(text_indices, text_scores):
        combined_scores[i] = combined_scores.get(i, 0) + alpha * score
    for i, score in zip(audio_indices, audio_scores):
        combined_scores[i] = combined_scores.get(i, 0) + (1 - alpha) * score

    # Urutkan berdasarkan skor gabungan
    ranked = sorted(combined_scores.items(), key=lambda x: x[1], reverse=True)

    # Ambil top_n tanpa lagu itu sendiri
    final_indices = [i for i, _ in ranked if i != idx][:top_n]

    # === Hitung cosine similarity rata-rata gabungan ===
    fitur_lagu_text = tfidf_matrix[idx]
    fitur_lagu_audio = audio_features[idx].reshape(1, -1)

    similarities_text = [cosine_similarity(fitur_lagu_text, tfidf_matrix[i])[0][0] for i in final_indices]
    similarities_audio = [cosine_similarity(fitur_lagu_audio, audio_features[i].reshape(1, -1))[0][0] for i in final_indices]

    hybrid_similarities = [alpha * t + (1 - alpha) * a for t, a in zip(similarities_text, similarities_audio)]
    print(f"[Hybrid] Rata-rata cosine similarity (gabungan): {np.mean(hybrid_similarities):.4f}")

    # Buat DataFrame untuk menampilkan hasil
    results_df = df[['track_name', 'track_genre']].iloc[final_indices].copy()
    results_df['cosine_similarity'] = hybrid_similarities

    return results_df

"""Fungsi diatas akan mengembalikan hasil rekomendasi lagu berdasarkan kombinasi kemiripan teks (judul, artis, genre) dan fitur audio (danceability, energy, dll.) melalui langkah-langkah berikut:
1. Menghitung kemiripan berdasarkan teks menggunakan TF-IDF + ANN.
2. Menghitung kemiripan berdasarkan fitur audio menggunakan ANN.
3. Menggabungkan skor dari kedua pendekatan dengan parameter bobot alpha (semakin tinggi, semakin menekankan aspek teks).
4. Mengembalikan daftar lagu yang paling mirip berdasarkan skor gabungan, tanpa menyertakan lagu input.
"""

recommend_and_evaluate_hybrid_text_audio("Levitating")

"""Untuk membuat rekomendasi dengan menggabungkan hybrid antara alunan musik dengan menjaga genre, maka disini saya menggabungkan kemiripan berdasarkan Fitur audio numerik (seperti danceability, energy, dsb) dan Genre (dalam bentuk representasi numerik juga)

**Rekomendasi Lagu berbasis Kemiripan Audio dan Genre (Hybrid)**
<br>Untuk genre akan diubah menjadi vektor biner dengan OneHotEncoder agar bisa digabung dengan fitur audio sehingga satu skala.
"""

from sklearn.preprocessing import OneHotEncoder

# Encoding genre
encoder = OneHotEncoder()
genre_encoded = encoder.fit_transform(df[['track_genre']]).toarray()

# Menggabungkan genre encoded dan fitur audio yang scaled
audio_genre_features = np.hstack((X_audio_scaled, genre_encoded))

# Membuat model ANN hybrid (audio + genre)
model_ann_audio_genre = NearestNeighbors(metric='euclidean', algorithm='brute')
model_ann_audio_genre.fit(audio_genre_features)

def recommend_and_evaluate_hybrid_audio_genre(song_title, df=df, features_matrix=audio_genre_features,
                                              model=model_ann_audio_genre, top_n=10):
    # Cari index lagu
    idx = df[df['track_name'].str.lower() == song_title.lower()].index
    if len(idx) == 0:
        return f"Lagu '{song_title}' tidak ditemukan dalam database."
    idx = idx[0]

    # Cari tetangga terdekat
    distances, indices = model.kneighbors([features_matrix[idx]], n_neighbors=top_n+1)
    recommended_indices = indices.flatten()[1:]

    # Hitung cosine similarity
    similarities = [cosine_similarity([features_matrix[idx]], [features_matrix[i]])[0][0]
                    for i in recommended_indices]

    # Buat DataFrame untuk menampilkan hasil
    results_df = df[['track_name', 'track_genre']].iloc[recommended_indices].copy()
    results_df['cosine_similarity'] = similarities

    print(f"[Hybrid Audio+Genre] Rata-rata cosine similarity: {np.mean(similarities):.4f}")
    return results_df

"""Berdasarkan kode di atas, rekomendasi lagu akan muncul berdasarkan kombinasi fitur audio dan genre menggunakan model Approximate Nearest Neighbors (ANN).
Langkah-langkah:
1. Mengambil representasi gabungan dari fitur audio dan genre.
2. Menggunakan ANN untuk mencari lagu-lagu dengan fitur gabungan yang paling mirip.
3. Mengembalikan daftar lagu mirip tanpa menyertakan lagu input.
"""

recommend_and_evaluate_hybrid_audio_genre("Levitating")

"""**Metrik Evaluasi Precision@K berbasis Ground Truth**"""

# Precision@K
def precision_at_k(recommended_songs, actual_songs, top_n=10):
    recommended_set = set(recommended_songs[:top_n])
    actual_set = set(actual_songs)
    precision = len(recommended_set.intersection(actual_set)) / top_n
    return precision

# Ground truth berdasarkan artis atau lagu yang sangat mirip
ground_truth = {
    "Blinding Lights": ["Save Your Tears", "In Your Eyes", "Take My Breath"],
    "Someone Like You": ["Hello", "When We Were Young", "All I Ask"],
    "Shape of You": ["Perfect", "Photograph", "Thinking Out Loud"],
    "Levitating": ["Don't Start Now", "Break My Heart", "Physical"],
    "drivers license": ["traitor", "deja vu", "good 4 u"]
}

# Fungsi evaluasi semua metode
def recommend_and_evaluate_all(song_title, df=df, tfidf_matrix=tfidf_matrix, audio_features=X_audio_scaled,
                               model_text=model_ann_text, model_audio=model_audio_ann,
                               model_ann_audio_genre=model_ann_audio_genre,
                               audio_genre_features=audio_genre_features,
                               top_n=10, alpha=0.5, ground_truth=None):

    # Rekomendasi berdasarkan metode
    recommendations_text = recommend_songs_text_based(song_title, df, model_text, tfidf_matrix, top_n)
    recommendations_audio = recommend_songs_audio_based(song_title, df, model_audio, audio_features, top_n)
    recommendations_genre = recommend_and_evaluate_by_genre(song_title, df, top_n)
    recommendations_hybrid = recommend_and_evaluate_hybrid_text_audio(song_title, df, tfidf_matrix, audio_features,
                                                                      model_text, model_audio, top_n, alpha)
    recommendations_audio_genre = recommend_and_evaluate_hybrid_audio_genre(song_title, df, audio_genre_features,
                                                                            model_ann_audio_genre, top_n)

    # Evaluasi Precision@K
    if ground_truth and song_title in ground_truth:
        relevant = ground_truth[song_title]
        precision_text = precision_at_k(recommendations_text['track_name'].tolist(), relevant, top_n)
        precision_audio = precision_at_k(recommendations_audio['track_name'].tolist(), relevant, top_n)
        precision_genre = precision_at_k(recommendations_genre['track_name'].tolist(), relevant, top_n)
        precision_hybrid = precision_at_k(recommendations_hybrid['track_name'].tolist(), relevant, top_n)
        precision_audio_genre = precision_at_k(recommendations_audio_genre['track_name'].tolist(), relevant, top_n)
    else:
        print("Tidak ada Ground Truth untuk lagu ini.")
        precision_text = precision_audio = precision_genre = precision_hybrid = precision_audio_genre = None

    return {
        'Precision@K (Text-Based)': precision_text,
        'Precision@K (Audio-Based)': precision_audio,
        'Precision@K (Genre-Based)': precision_genre,
        'Precision@K (Hybrid Text+Audio)': precision_hybrid,
        'Precision@K (Audio+Genre)': precision_audio_genre
    }

result = recommend_and_evaluate_all("Levitating", ground_truth=ground_truth)
print(pd.DataFrame(result.items(), columns=["Method", "Precision@K"]))

"""## Evaluation
Evaluasi ini bertujuan untuk mengukur kualitas rekomendasi lagu berdasarkan dua metrik utama: **Cosine Similarity** untuk kemiripan fitur dan **Precision@K** untuk kualitas rekomendasi.

### Hasil Evaluasi pada lagu berjudul "Levitating"

| Metode                       | Cosine Similarity | Precision@K |
|-----------------------------|-------------------|-------------|
| **Text-Based**               | 0.6884            | 0.3         |
| **Audio-Based**              | 0.9834            | 0.0         |
| **Genre-Based**              | 1.0000            | 0.0         |
| **Hybrid Text + Audio**      | 0.5829            | 0.2         |
| **Hybrid Audio + Genre**     | 0.9438            | 0.0         |

### Interpretasi Hasil

- Model **Audio-Based** dan **Genre-Based** memiliki nilai kemiripan tertinggi, menandakan bahwa lagu-lagu yang direkomendasikan sangat mirip secara fitur.
- Namun, **kemiripan tinggi tidak selalu berarti relevansi tinggi** secara kontekstual.
- Model **Hybrid Text + Audio** memiliki kemiripan paling rendah, namun bisa saja menangkap konteks yang lebih bervariasi.
- Model **Text-Based** menunjukkan performa terbaik dalam hal relevansi lagu yang direkomendasikan.
- Model **Audio-Based** dan **Genre-Based** gagal menghasilkan rekomendasi yang relevan menurut ground truth, meskipun secara fitur sangat mirip.
- Model **Hybrid Text + Audio** menghasilkan performa moderat, menunjukkan bahwa penggabungan fitur dapat memberikan manfaat, namun perlu optimasi lebih lanjut.

### Kesimpulan
- **Cosine similarity tinggi** tidak selalu berbanding lurus dengan **relevansi** rekomendasi.
- Model berbasis **teks** lebih andal dalam menghasilkan rekomendasi yang relevan meskipun fitur kemiripannya lebih rendah.


### Kesimpulan Project
Dari eksplorasi yang telah dilakukan, ***Problem Statements*** di atas akhrinya terjawab berdasarkan uraian berikut:
1. Cara merekomendasikan lagu yang serupa dengan lagu favorit pengguna dilakukan dengan pendekatan Content-Based Filtering, yang memanfaatkan fitur-fitur deskriptif lagu (seperti nama lagu, artis, genre, album) dan fitur audio (seperti danceability, valence, tempo). Fitur-fitur ini diubah menjadi representasi vektor menggunakan TF-IDF, kemudian dihitung tingkat kesamaannya menggunakan Approximate Nearest Neighbors (ANN) dan Cosine Similarity. Selanjutnya dilakukan penghitungan Precision@K untuk mengukur kualitas berdasarkan Ground Truth.
2. Untuk membantu pengguna menemukan lagu baru tanpa pencarian manual, sistem secara otomatis memberikan rekomendasi lagu yang mirip berdasarkan lagu favorit pengguna. Proses ini bersifat personal dan relevan karena mempertimbangkan karakteristik musik yang disukai pengguna, sehingga mereka tidak perlu melakukan pencarian eksplisit.
"""